"use strict";(self.webpackChunkmagellan_site=self.webpackChunkmagellan_site||[]).push([[918],{532:(e,a,t)=>{t.r(a),t.d(a,{default:()=>r});t(43);var i=t(181);const n=t.p+"static/media/magellan_tech_about_image.276571ba55977c8e0290.png";var s=t(579);const r=()=>(0,s.jsx)(i.A,{title:"About",description:"About MagellanTech.",children:(0,s.jsxs)("article",{className:"post",id:"about",children:[(0,s.jsx)("header",{children:(0,s.jsx)("div",{className:"title",children:(0,s.jsx)("h2",{children:"About"})})}),(0,s.jsx)("h3",{children:"Entity Matching"}),(0,s.jsx)("span",{className:"image right",children:(0,s.jsx)("img",{src:n,alt:"Diagram illustrating blocking and matching in entity matching"})}),(0,s.jsxs)("p",{children:["Entity Matching (EM) is the problem of finding data instances that refer to the same real-world entity. For example, given the two tables A and B shown below, find all tuple pairs (a in A, b in B) that match, such as (Dave Smith, Madison, WI) and (David D. Smith, Madison, WI). We call these pairs ",(0,s.jsx)("b",{children:"matches"}),"."]}),(0,s.jsx)("p",{children:"EM arises frequently in data science and AI. Many projects must integrate multiple datasets into a single, clean, unified dataset before analysis or model training can take place. Solving the entity matching problem is often a necessary step in this integration process."}),(0,s.jsxs)("p",{children:["The EM problem is challenging for two main reasons. First, matching instances may be represented in different ways\u2014using different names, formats, or levels of detail\u2014making"," ",(0,s.jsx)("b",{children:"high-accuracy matching"})," difficult. Second, real-world datasets are often very large: tables commonly contain hundreds of millions of tuples, which makes achieving"," ",(0,s.jsx)("b",{children:"reasonable runtime and scalability"})," a major challenge."]}),(0,s.jsx)("h3",{children:"Blocking and Matching"}),(0,s.jsxs)("p",{children:["For large tables, considering all possible pairs between tables A and B is computationally infeasible. As a result, entity matching is typically performed in two stages:"," ","blocking and matching. (The Magellan project develops software that supports both stages.)"]}),(0,s.jsxs)("p",{children:["In the ",(0,s.jsx)("b",{children:"blocking"})," stage, inexpensive heuristics are used to quickly eliminate the vast majority of tuple pairs that are unlikely to match. The goal is to dramatically reduce the search space while retaining most true matches."]}),(0,s.jsxs)("p",{children:["In the ",(0,s.jsx)("b",{children:"matching"})," stage, a more expensive rule-based or machine-learning\u2013based matcher is applied to the remaining candidate pairs to predict whether each pair is a match or a non-match."]}),(0,s.jsx)("p",{children:"For example, in the figure above, the blocking step retains only pairs that share the same state (which can be done efficiently using an index on the State column). The matching step then applies a matcher that correctly predicts pairs (a1,b1) and (a3,b2\u200b) as matches."}),(0,s.jsx)("h3",{children:"Variations of EM and Related Problems"}),(0,s.jsxs)("p",{children:["Variations of EM are known as ",(0,s.jsx)("b",{children:"entity resolution, record linkage, deduplication,"})," and more. We use the term ",(0,s.jsx)("b",{children:"entity matching"})," because it emphasizes the common structure shared by these tasks and aligns with a broader set of related problems whose names end with"," ",(0,s.jsx)("i",{children:"matching"}),"."]}),(0,s.jsxs)("p",{children:["Specifically, ",(0,s.jsx)("b",{children:"string matching"}),' finds strings that refer to the same real-world concept, such as "UW-Madison" and "Univ of Wisc Madison". ',(0,s.jsx)("b",{children:"Schema matching"}),' finds similar columns across tables, such as "address" and "location". ',(0,s.jsx)("b",{children:"Ontology matching"})," ",'finds similar concepts across ontologies, such as "car" and "automobile". Other related problems include matching between ontology concepts and table columns, matching tables, and more.']}),(0,s.jsx)("p",{children:"While Magellan is designed primarily for EM, it can also be used for these related matching problems."}),(0,s.jsx)("h3",{children:"The Magellan Project"}),(0,s.jsxs)("p",{children:["The Magellan project was launched in 2015 at the University of Wisconsin\u2013Madison. At the time, despite a large body of research on entity matching, we found little"," ","industrial-strength software that could be readily used in practice. Our goal has therefore been to develop ",(0,s.jsx)("b",{children:"open-source, production-quality entity matching software"}),", evaluate it through collaborations with real users, use this feedback to refine the software, and publish the resulting findings."]}),(0,s.jsxs)("p",{children:["A central objective of Magellan is to release EM software that achieves"," ","widespread adoption. While publishing research is an important part of the project, it is viewed as a consequence of executing this iterative"," ","software\u2013user\u2013refinement cycle, rather than an end in itself."]}),(0,s.jsx)("h3",{children:"Team and Contact"}),(0,s.jsxs)("p",{children:["Many people have contributed to the Magellan project over the years. A list of contributors can be found in the"," ",(0,s.jsx)("a",{href:"./research",children:"Research"})," ","section of this website."]}),(0,s.jsxs)("p",{children:["For inquiries or collaboration requests, please contact us at"," ",(0,s.jsx)("a",{href:"mailto:entitymatchinginfo@gmail.com",children:"entitymatchinginfo@gmail.com"}),"."]})]})})}}]);
//# sourceMappingURL=918.37afca8f.chunk.js.map